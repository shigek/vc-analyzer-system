主局（トリガー）が `Spring Boot` で構築された**サーバー**である場合の、MPC（マルチパーティ計算）における通信と役割分担の確認ですね。これは、モバイルアプリ（P1）がサーバー（P2）からの指示を受けてMPCを開始・進行する、非常に一般的なシナリオです。

### 構成の明確化

* **P1**: モバイルアプリ (Flutter + Rust/Kotlin/Swift)
* **P2**: Spring Boot サーバー (MPCコーディネーター/ブートストラップサーバー)
* **MPCプロトコル**: FROST (DKG or 署名)

### Spring Boot サーバーが主局（トリガー）となる場合の通信フロー

このシナリオでは、**P2（Spring Boot サーバー）がMPCセッションの開始を調整し、モバイルアプリ（P1）にその処理を促す**役割を担います。

#### 1. MPCセッションの開始トリガー（Spring Boot サーバー主導）

Spring Boot サーバーがMPCセッションを開始するトリガーは様々です。

* **外部からのリクエスト**: 別のシステム（管理画面、決済システムなど）からのAPIコール。
* **スケジュールされたタスク**: 特定の時刻に自動でDKGや鍵ローテーションを開始。
* **ユーザー操作（Web UI経由）**: 管理者がWeb UIから特定のユーザーの鍵操作を指示。

このトリガーを受けて、Spring Boot サーバーはMPCセッションを開始し、必要な初期メッセージを生成します。

#### 2. Spring Boot サーバーからモバイルアプリへの通信（トリガーと最初のMPCメッセージ）

P2（Spring Boot サーバー）がP1（モバイルアプリ）に通信を開始する方法は、モバイルの特性を考慮する必要があります。

* **a. プッシュ通知 (FCM / APNs)**:
    * **P2**: Spring Boot サーバーは、MPCセッションの開始準備ができたことを、P1のデバイスに**プッシュ通知**（Android向けFCM、iOS向けAPNs）として送信します。
    * **P1**: モバイルアプリはプッシュ通知を受け取ると、フォアグラウンドまたはバックグラウンドで起動し、P2（Spring Bootサーバー）のAPIエンドポイントへ問い合わせを行います。
    * **メリット**: バッテリー効率が良い、アプリが起動していなくてもメッセージを届けられる、リアルタイム性が高い。
    * **デメリット**: プッシュ通知のペイロードサイズに制限がある、通知インフラのセットアップが必要。

* **b. WebSocket / MQTT の利用 (P1が常時接続の場合)**:
    * **P1**: モバイルアプリがSpring Bootサーバーが提供するWebSocketまたはMQTTブローカーに**常時接続（または頻繁に接続）**している場合、P2は中間メッセージを直接プッシュできます。
    * **P2**: Spring BootサーバーがWebSocketサーバーやMQTTブローカーとして機能するか、外部のMQサービス（例: RabbitMQ, AWS IoT Core+MQTT）を利用してメッセージをP1に直接送信します。
    * **メリット**: リアルタイム性が最も高い、メッセージサイズ制限が緩い。
    * **デメリット**: モバイル側での接続維持によるバッテリー消費、iOSでのバックグラウンドでの持続接続の制約。

* **c. ポーリング (P1が定期的に問い合わせる場合)**:
    * **P1**: モバイルアプリが定期的に（例: アプリ起動時、特定の間隔で）Spring BootサーバーのAPIエンドポイントに問い合わせ、「私宛のMPCセッションやメッセージはありますか？」と確認します。
    * **P2**: P1からのリクエストに対して、保留中のMPCセッション情報や中間メッセージを返します。
    * **メリット**: 実装がシンプル。
    * **デメリット**: リアルタイム性が低い、ポーリング頻度によってはバッテリー消費が大きい。

**選択肢 a. のプッシュ通知**が、モバイルデバイスの特性を最も考慮した「主局からのトリガー」としては最適解の一つです。プッシュ通知でアプリを起動させ、その後に実際のMPCメッセージのやり取りを開始します。

#### 3. MPC中間メッセージの交換（P1 と P2 間）

MPCプロトコル（FROST）は複数ラウンドを必要とします。この中間メッセージの交換は、以下のような形式で行われます。

* **a. RESTful API (HTTPS)**:
    * 最もシンプルで広く使われる方法。各ラウンドでP1とP2がHTTPS POST/GETリクエストを送信し、中間メッセージ（通常はJSON形式でシリアライズ）をやり取りします。
    * **P1 -> P2**: モバイルが計算した中間メッセージをSpring Bootサーバーの特定APIエンドポイントに送信。
    * **P2 -> P1**: Spring Bootサーバーが計算した中間メッセージをモバイルからのリクエストへのレスポンスとして返す、またはモバイルがポーリングで取得。
    * **セキュリティ**: TLSで通信が暗号化されます。メッセージ自体の認証（署名など）も追加すると良いでしょう。

* **b. WebSocket / MQTT (リアルタイム性重視)**:
    * もし、各MPCセッションでリアルタイムなやり取りが非常に重要であれば、WebSocketやMQTTを使って、持続的な接続上で中間メッセージを交換します。
    * Spring BootはWebSocketエンドポイントを簡単に提供できます。MQTTブローカーもSpring Bootアプリケーションからアクセスできます。

#### 4. MPCプロトコルの進行と結果

* Spring Bootサーバーは、P1からの中間メッセージを受け取り、自身のシェアとFROSTライブラリを使って計算を進めます。
* 必要に応じて、P1に次の中間メッセージを送信します。
* 最終的に、P1とP2が協力して、署名（またはDKGの結果）を完成させます。
* この最終的な署名結果は、どちらかの参加者（例えばSpring Bootサーバー）がブロックチェーンに送信するか、モバイルアプリがユーザーの承認を得て送信します。

### Spring Bootの役割（ブートストラップサーバー/コーディネーター）

* **セッション管理**: 各MPCセッションの開始、状態管理、参加者（P1, P2,...）の追跡。
* **メッセージルーティング**: P1から受け取ったメッセージを必要に応じて他の参加者（もしTSSが2者以上の場合）に転送し、P2自身のメッセージをP1に送信。
* **鍵とシェアの安全な管理**: P2自身のシェアを安全に保存し、MPC計算時に利用。
* **監査とロギング**: MPCセッションの進行状況や結果を記録。
* **スケーラビリティと可用性**: 多数のモバイルユーザーからのリクエストを処理するための負荷分散や高可用性設計。

このアーキテクチャでは、Spring BootサーバーがMPCプロトコルの信頼できる「調整役」となり、モバイルアプリはサーバーからの指示に従って計算に参加し、必要な情報を提供する役割を担います。